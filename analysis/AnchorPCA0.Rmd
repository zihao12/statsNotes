---
title: "AnchorPCA0"
author: "zihao12"
date: "2021-05-27"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---


* Goal is try "AnchorPCA" : (TODO: put link). The motivation is from anchor regression https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssb.12398
* Model:

For $Y$, the data generating process . 
\begin{align}
    & Y = B X + M H + \epsilon \\
    & X \sim N(0, I_k)\\
    & H \sim N(0, \Sigma_H)\\
    & \epsilon \sim N(0, \sigma^2 I_p)\\
    & X, H, \epsilon \ \text{are independent}
\end{align}

For anchor variable $A$, it's generated by the same $(X, H)$. 

\begin{align}
    & A = W_1 X + W_2 H + \epsilon_A\\
    & \epsilon_A \sim N(0, \sigma^2 I_L)\\
\end{align}

* Basic idea is use $A$ to create perturbed $Y$: $$\tilde{Y} = (Id - PA)(Y) + \sqrt{\gamma} PA(Y)$$ with $PA(Z) = E(Z|A)$ here. Then apply PCA on observation matrix of $\tilde{Y}$
* I first run vanilla PCA on IRIS dataset (assuming here indeed $Y = BX + \epsilon$), then add artificial $H, A$ to create `case 1` and `case 2` as in the write-up. 
* The goal is proof of concept: I want to test for the extreme cases when $\gamma = 0, \infty$ makes sense. Next step is to find more realistic cases where interpolation between the two extremes work better. 

```{r}
rm(list =ls())
set.seed(123)

perturb <- function(Y, A, gam){
  Y = as.matrix(Y)
  fit =lm(Y ~ A)
  Ytilde = sqrt(gam) * fit$fitted.values + fit$residuals
  return(Ytilde)
}
```



```{r}
data("iris")
summary(iris)
n= nrow(iris)
df <- iris
#df <- iris[sample(x = 1:n,size = n,replace = FALSE),]
df[,1:4] = scale(df[,1:4])


fit.svd= svd(x = df[,1:4],nu = 2,nv = 2)
fit.svd$d
plot(fit.svd$u[,1], fit.svd$u[,2],col = df$Species)
```
We can identify 3 clusters by PC1 &PC2 that correspond to the 3 species. 




## Case I:

* In this case we can think of $a_i \in \{1,2,..., L\}$ as independent of $x_i$, as I assign the same number of samples within each species to the same batch ID. 
*Therefore it makes sense to partialize out the effect of $A$ on $Y$ first, then apply PCA. In the AnchorPCA framework, this corresponds to $\gamma = 0$. 
* Indeed we can see $\gamma = 0$ works better than other cases. 
```{r}
df_ = df
#df_[,"batch"] = sample(as.integer(df_$Species),size = n, replace = FALSE)
for(i in 1:3){
  start_idx = (i-1)*17 + 1
  end_idx = min(i*17, 50)
  ixs <- start_idx:end_idx
  ixs <- c(ixs, ixs + 50, ixs + 100)
  df_[ixs,"batch"] <- i
}

batch_shift = c(0, 1,2)
for(i in 1:3){
  l = sum(df_$batch == i)
  df_[df_$batch == i, 1:4] = df_[df_$batch == i, 1:4] + 
    rnorm(l*4,mean = batch_shift[i],sd = 1) 
}

## anchor PCA 
par(mfrow = c(2,2))
for(gam in c(10, 1, 0.3, 0)){
  Ytilde = perturb(Y = df_[,1:4], A = df_$batch,gam= gam)
  fit.svd= svd(x = Ytilde,nu = 4,nv = 4)
  fit.svd$d
  plot(fit.svd$u[,1], fit.svd$u[,2],col = df_$Species, main = sprintf("gam = %.2f", gam))
}
```
Indeed we can see with smaller $\gamma$, the biological structure seems clearer


## Case II

* I let $Y = A + H + \epsilon$ and $A = BX$. So it makes sense to do PCA on $A$ instead of $H$. This is equavelent to work on $\tilde{Y} = PA(Y) = A$, corresponding to $\gamma = \infty$. 
* Indeed it can find structure when $\gamma$ is large. 
```{r}
df_ = df
A = df_[,1:4]
H = matrix(, nrow = nrow(A), ncol = ncol(A))
df_[,"batch"] = sample(as.integer(df_$Species),size = n, replace = FALSE)
batch_shift = c(0, 0.5,1)
for(i in 1:3){
  l = sum(df_$batch == i)
  H[df_$batch == i, ] = rnorm(l*4,mean = batch_shift[i],sd = 1)
}
Y = H + A

## anchor PCA 
par(mfrow = c(2,2))
for(gam in c(100000, 1, 0.3, 0)){
  Ytilde = perturb(Y = Y, A = as.matrix(A), gam= gam)
  fit.svd= svd(x = Ytilde,nu = 4,nv = 4)
  fit.svd$d
  plot(fit.svd$u[,1], fit.svd$u[,2],col = df_$Species, main = sprintf("gam = %.2f", gam))
}
```








